#ifndef FSM_H
#define FSM_H

#include "elev.h"
#include "queue_handler.h"

#include "time.h"

/**
 * @file 
 * @brief The FSM interface.
 * To create an FSM module to use add the FSM_MODULE macro with your defines and includes.
 * Now pass the module to the run_fsm(fsm_t* fsm_p) function
 */ 

/**
 * @def FSM_MODULE(_name)
 * This macro is used to create and instantiate a new fsm_module_struct.
 * This should always have a unique name and the run fsm function should be passed a pointer to this module.
 * @param _name This is the name given to the new module. 
 */
#define FSM_MODULE(_name)   \
static fsm_t _name =        \
{INIT_STATE,                \
0,                          \
DIRN_STOP,                  \
init_state_function,        \
{                           \
up_state_function,          \
down_state_function,        \
standby_state_function,     \
serve_order_state_function, \
stop_state_function,        \
init_state_function         \
}};

enum state_enumeration;
struct fsm_module_struct;

/**
 * @brief The state_t connects states to their indexes in the state array.
 * 
 */
typedef enum state_enumeration state_t;

/**
 * @brief The fsm_t holds an instance of the state machine module.
 * 
 */
typedef struct fsm_module_struct fsm_t;

/**
 * @brief Defines the prototype of all state functions
 * To have an easy expandable interface, all state functions follow this 
 * prototype, so that they can be fitted into the state function array.
 */
typedef state_t (*state_function_t)(fsm_t* fsm_p, order_queue_t* queue_p);

enum state_enumeration {
    UP_STATE,
    DOWN_STATE,
    STANDBY_STATE,
    SERVE_ORDER_STATE,
    STOP_STATE,
    INIT_STATE,
    STATES_N
};


/**
 * @brief The fsm struct that implements the fsm module
 * 
 */
struct fsm_module_struct{
    state_t state;
    int _init;
    elev_motor_direction_t  _dir;
    state_function_t current_state_function;
    const state_function_t state_function_array[STATES_N];
    time_t _timestamp;
};

/**
 * @brief Run the state machine.
 * @remark This function is blocking
 * 
 * This takes in a pointer to the FSM module generated by FSM_MODULE and runs the state machine.
 * 
 * @param fsm_p Pointer to the FSM object 
 * @param queue_p  Pointer to the order queue handler.
 * @return int Error message
 */
int run_fsm(fsm_t* fsm_p, order_queue_t* queue_p);

/**
 * @brief While the elevator is going up, this state is run.
 * 
 * @param fsm_p Pointer to a fsm object.
 * @param queue_p  Pointer to an order queue handler.
 * @return state_t The next state that the FSM should transition to.
 */
state_t up_state_function(fsm_t* fsm_p, order_queue_t* queue_p);

/**
 * @brief While the elevator is going down, this state is run.
 * 
 * @param fsm_p Pointer to a fsm object.
 * @param queue_p  Pointer to an order queue handler.
 * @return state_t The next state that the FSM should transition to.
 */
state_t down_state_function(fsm_t* fsm_p, order_queue_t* queue_p);

/**
 * @brief While the elevator is at a standstill, this state is run.
 * 
 * @param fsm_p Pointer to a fsm object.
 * @param queue_p  Pointer to an order queue handler.
 * @return state_t The next state that the FSM should transisiton to.
 */
state_t standby_state_function(fsm_t* fsm_p, order_queue_t* queue_p);

/**
 * @brief When the FSM is at a floor with an order, this state serves it.
 * 
 * @param fsm_p Pointer to an fsm object
 * @param queue_p  Pointer to an order queue handler.
 * @return state_t The next state
 */
state_t serve_order_state_function(fsm_t* fsm_p, order_queue_t* queue_p);

/**
 * @brief When the stop button is pressed, this state will be run.
 * 
 * @param fsm_p Pointer to a fsm object.
 * @param queue_p  Pointer to an order queue handler.
 * @return state_t The next state that the FSM should transition to.
 */
state_t stop_state_function(fsm_t* fsm_p, order_queue_t* queue_p);

/**
 * @brief While the elevator is initializing, this state will be run.
 * 
 * @param fsm_p Pointer to a fsm object.
 * @param queue_p  Pointer to an order queue handler.
 * @return state_t The next state that the FSM should transition to.
 */
state_t init_state_function(fsm_t* fsm_p, order_queue_t* queue_p);


#endif //FSM_H
